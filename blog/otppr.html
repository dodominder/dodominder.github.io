<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="../images/favicon.ico" />
<link rel="stylesheet" href="../styles/style.css" />
<title>Dal9000</title>
</head>
<body>
<img src="../images/logos.png" class="dallogo">
<div class="navi">	
<ul>
  <li><a href="../index.html">Blog</a></li>
  <li><a href="../papers.html">Papers</a></li>
  <li><a href="../notes.html">Notes</a></li>
  <li><a href="../about.html">About</a></li>
</ul>
</div>

<div class="maintext">
<h1>The OTP with a pseudo-random seed?</h1>
<p>
The One-time pad (OTP) is a technique of encryption that uses a key that is randomly generated. The key must be as long or longer than the plaintext and the key cannot be reused. This type of encryption was employed during the 20th century by diplomats and for espionage. Two parties that needed to exchange information are given identical copies of a code book. This book would consist of a stream of random digits. Each symbol in the plaintext is associated with a number. After performing a reversible operation on the plaintext letter along with a digit from the stream a number is produced that is associated with the original symbols of the plaintext. After each page of the code book was used it was destroyed.
</p><p>

An implementation of the OTP, namely the Vernam cipher, was proven unbreakable by Claude Shannon in 1949. With the implication that the OTP in general is unbreakable. The weakness of the OTP is the need for a constant supply of new numbers. This was a larger issue during the last century since the code books had to physically exist. A modern implementation could use two thumb drives that contain hundreds of gigabytes of random numbers.
</p><p>

<h3>Examples</h3>
Given a random stream of numbers 40392 one could encrypt the word "Hello" by associating the letters with their numerical position in the alphabet and adding the random digits.
<pre>
Hello -> 8 5 12 12 15
         + 4 0 3 9 2
         12  5  15  21  17

12 5 15 21 17 -> leouq
        Hello -> leouq
 </pre>


If the sum goes beyond 26 wrap around the alphabet. <br />
a &#8803; b + y mod (26)
To decrypt the text reverse the operation using the random digits. 
So far we have only used 26 letters. It would be nice to include more typographical symbols and perhaps include modular arithmetic, which has inverses for every element except 0 when the modulus is prime.

<pre>
  a b c d e f g h i  j  k  l  m  n  o  p
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
 q  r  s  t  u  v  w  x  y  z  .  ?  '  ,
17 18 19 20 21 22 23 24 25 26 27 28 29 30 
</pre>

 Given a stream of random numbers 28934183487114 we can use the following formula, where P is the plaintext character, C is the ciphered text and b<sub>n</sub>, b<sub>n+1</sub> are the consecutive numbers from the stream.<br />
 
 C &#8803; Pb<sub>n</sub> + b<sub>n+1</sub>  mod (31) <br />
The word <i>puzzle?</i> becomes <i>ifwyyea</i>. <br />
This formula uses two consecutive numbers which requires the key to be at least twice as long as the plaintext.<br />
In this example the symbol ? encrypts as <br />
 ?*b<sub>13</sub> + b<sub>14</sub>  mod (31) <br />
 28 * 1 + 4  mod (31) <br />
 a = 1 &#8803; 32 mod(31) <br />
</p>
<p>
Sadly we can't use multiplication even if the modulus is prime. Zero doesn't have an inverse but we can get around this fact if we restrict our random digits to numbers 1 through 9. Otherwise we are stuck with addition and subtraction.</p>
<p>
The OTP is already unbreakable so it is superfluous to use two digits to encrypt each symbol. This was just to demonstrate other possible operations.
</p>
<p>
<h3>Random Numbers</h3>
The random digits used to  
create the key needs to be truly random. There exists many pseudo-random number generating algorithms (PRG) which can approximate a random sequence of numbers. The issue with any pseudo-random algorithm is that if the seed number is known then the sequence of "random numbers" is completely determined.
</p>
<p>
If two parties who wished to exchange information via a OTP they could avoid the issue of running out of truly random numbers by agreeing to use a PRG and by agreeing on a starting number. Any such encryption is breakable if the PRG being used is known. Actually this type of encryption is known as a "stream cipher." This encryption is no longer unbreakable.
</p>
<p> It may appear that we can avoid the issue by letting the seed be randomly chosen for each message. Two parties could, for example, decide to use outcomes of football games to determine the seed value. This would be random but it would also make the encryption less secure! If the seed is randomly chosen then eventually the same seed will be used more than once. The point of the OTP is to never reuse the same numbers. EVER. 
</p>
<p>
To encrypt something that's truely unbreakable use truely random digits.
</p>
<p>
	Side note:<br >
	I was playing around with an algorithm to generate pseudo-random numbers. This algorithm relies on the decimal expansion of irrational numbers. Basically take two numbers with an equal amount of digits. Use the digits in the first number as the nth root of the digits in the second. Neither number can contain 0 or 1. <br /> 
	If the nth root is a natural number then switch the places of the digits. For example 222, 444 won't work because the square root of 4 is 2. Switch the digits. The fourth root of 2 is irrational and so has a non-repeating decimal place. <br /> 
	After obtaining the decimal expansions remove the first digit, which is extremely predictable. Read the numbers from top to bottom for each column and the columns from left-to-right. Voilà. 
</p><p>
Example: 324, 236 <br />
	&#8731; 2 = 1.25992104989... -> 25992104989...<br />
	&#8730; 3 = 1.73205080757... -> 73205080757...<br />
	&#8732; 6 = 1.56508458007... -> 56508458007...<br />
</p>
<p>This becomes <br />
275536925900258104085408975850977...
</p>

<p>
I wrote a couple python scripts to generate random numbers this way. Along with encoding and decoding text saved in a file in the same directory the script is run from. 
If you know python well enough you can figure out what's going on <a href="https://github.com/dodominder/dodominder.github.io/tree/master/code/python/pseudoRandom_OTP" >here</a>.
</p>


</div>


</body>
</html>